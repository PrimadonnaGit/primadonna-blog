---
title: 카프카 컨슈머의 동작 방식 이해하기
date: '2023-12-19'
tags: ['kafka', 'consumer', 'book study']
draft: false
summary: 카프카 핵심 가이드 Chapter 4 스터디 내용 정리입니다.
authors: ["default"]
---

# Consumer

- 카프카 컨슈머는 보통 **컨슈머 그룹(consumer group)** 의 일부로서 작동
- 컨슈머 그룹의 특징 (리밸런싱)을 사용하지 않고 단일로도 작동할 수 있음 (-> standalone consumer)
- 동일한 컨슈머 그룹에 속한 여러 개의 컨슈머들이 동일한 토픽을 구독할 경우, 각각의 컨슈머는 해당 토픽에서 서로 다른 파티션의 메세지를 받는다.
- 서로 다른 컨슈머 그룹의 컨슈머들은 같은 토픽을 구독하더라도 서로 영향이 없음 -> 같은 토픽을 여러 어플리케이션, 여러 요구사항으로 분리할 수 있다는 뜻
- 보통 컨슈머를 추가함으로써 단위 컨슈머가 처리하는 파티션과 메세지의 수를 분산시키는 것이 일반적인 규모 확장 방식임

> Q. 같은 컨슈머 그룹에서 각각의 컨슈머가 다른 토픽을 구독할 수 있다는 얘기인가?
> - 이것은 각 컨슈머가 다른 토픽을 구독할 수 있다는 것을 의미하지 않습니다. 동일한 컨슈머 그룹 내의 컨슈머들이 다른 토픽을 구독하려면, 해당 컨슈머들은 각각 다른 컨슈머 그룹에 속해야 합니다. 같은 컨슈머 그룹 내에서는 모든 컨슈머가 동일한 토픽 세트를 구독해야 하며, 이를 통해 토픽의 파티션들이 컨슈머 그룹 내의 서로 다른 컨슈머들 사이에 효율적으로 분배됩니다.

> Q. 컨슈머가 서로 다른 그룹에 할당될 수 있나? X
> - 파티션은 한 컨슈머 그룹에서 반드시 하나의 컨슈머와 대응됨. (그 이외 컨슈머가 존재한다면 유휴 컨슈머가 됨)

# Consumer Group

- 컨슈머는 `group.id`를 통해 식별되며 같은 `group.id`를 갖는 컨슈머는 같은 컨슈머 그룹에 속하게 됨
- **그룹 코디네이터(Group Coordinator)** 는 브로커 쪽에 위치하여 최초 그룹에 조인한 컨슈머를 리더로 지정하고 토픽 파티션 할당을 계산하는 역할을 담당


# Partition Rebalancing

컨슈머에 할당된 파티션을 다른 컨슈머에게 할당해주는 작업

**발생 상황**
- 새로운 컨슈머가 추가되어 다른 컨슈머가 읽고 있던 파티션으로 부터 메세지를 받는 경우
- 컨슈머가 종료되어 크래시가 났을 경우
- 컨슈머 그룹이 읽고 있는 토픽에 변경 사항이 생겼을 경우 (파티션 추가 등)

## Rebalance Protocol

### 조급한 리밸런스 (eager rebalance)

1. 모든 컨슈머는 읽기 작업을 멈추고, 자신에게 할당된 모든 파티션에 대한 소유권을 포기
2. 모든 컨슈머가 컨슈머 그룹에 다시 참여(rejoin)하여 완전히 새로운 파티션 할당을 전달받음

- 전체 컨슈머 그룹에 대해 짧은 시간 동안 작업이 멈춤 (stop-the-world)

### 협력적/점진적 리밸런스 (cooperative rebalence, incremental rebalence)

한 컨슈머에 할당되어 있던 파티션만을 다른 컨슈머에 재할당함
재할당되지 않는 컨슈머들은 작업에 방해받지 않음
(3.1 버전 이후 기본값)

1. 컨슈머 그룹 리더가 다른 컨슈머들에게 일부 파티션이 재할당 될 것을 알림
1. Q. 컨슈머 리더가 어떻게 다른 컨슈머에게 알리지?
2. A. 리더가 그룹 코디네이터에게 해당 그룹 안에 있는 모든 컨슈머의 목록을 받아 전달한다.
2. 통보받은 컨슈머들을 해당 파티션에 대한 작업을 멈추고 소유권을 포기 (1차)
3. 컨슈머 그룹 리더가 포기된 파티션들을 새로 할당 (2차)


> 컨슈머는 해당 컨슈머 그룹의 그룹 코디네이터(group coordinator) 브로커에 heartbeat를 전송함으로써 멤버십과 할당된 파티션의 소유권을 유지
> heartbeat는 컨슈머의 백그라운드 쓰레드에 의해 일정 간격으로 전송됨


# Static Group Membership

컨슈머가 갖는 컨슈머 그룹의 멤버십은 일시적이며 컨슈머 그룹을 떠나는 순간 할당되어 있던 파티션들은 해제되고, 다시 참여하면 새로운 멤버 ID가 발급되어 리밸런스 프로토콜에 의해 새로운 파티션들이 할당 된다.

하지만 컨슈머에 고유한 `group.instance.id` 를 할당해주면 정적 멤버로서 rejoin시 멤버십이 그대로 유지되어 리밸런스가 발생할 필요 없이 기존 할당받았던 파티션들을 그대로 할당받는다.
때문에 해당 파티션은 다른 컨슈머에게 재할당되지 않으므로 rejoin시 밀린 메세지들을 따라 잡을 것인지에 대해 확인 할 필요가 있다.

이는 애플리케이션이 각 컨슈머에 할당된 파티션의 내용들을 이용해 로컬 상태나 캐시를 유지해야 할 때 편리하다.


# Offset and Commit

카프카는 일반적인 MQ 처럼 컨슈머로부터의 응답을 받는 형식이 아니라, 카프카를 사용해 각 파티션에서의 위치를 추적할 수 있다.

> Message Queue는 컨슈머가 메세지 소비 후 ACK 메세지를 전달받아 해당 메세지를 삭제한다.
> https://escapefromcoding.tistory.com/705

**파티션에서의 현재 위치(읽은 레코드)를 업데이트하는 작업을 오프셋 커밋**이라 하며, 전통적인 MQ와는 다르게 레코드를 개별 커밋하지 않고, 컨슈머가 **성공적으로 처리해 낸 마지막 메세지를 커밋**하여 그 앞의 메세지는 암묵적으로 성공하였다고 나타낸다.

> **컨슈머가 오프셋을 커밋하는 방법**
> 카프카의 특수 토픽인 `__consumer_offsets` 토픽에 각 파티션별로 커밋된 오프셋을 업데이트

리밸런스 이후 각각의 컨슈머들은 리밸런스 이전에 처리하고 있던 파티션의 마지막 작업 대상 메세지를 찾기 위해 커밋된 메세지를 활용한다.

**"커밋된 오프셋" 과 "클라이언트가 처리한 마지막 메세지의 오프셋" 의 차이**
1. 커밋된 오프셋 < 클라이언트가 처리한 마지막 메세지의 오프셋
1. 클라이언트에서 이미 더 많은 메세지를 처리했으므로 리밸런싱된 컨슈머는 메세지를 중복 처리하게 된다.
2. 커밋된 오프셋 > 클라이언트가 처리한 마지막 메세지의 오프셋
1. 클라이언트가 처리하지 못한 메세지들이 컨슈머 그룹에서 누락되게 된다.

> "클라이언트가 처리한 마지막 메세지의 오프셋" 은 사실 바로 그 다음 오프셋(+1)을 커밋하는 것이 기본 동작이나, 대부분의 경우 별 상관이 없다. 다만 수동으로 커밋하게 된다면 유의해야함

## Auto Commit

`enable.auto.commit=true` 설정으로 컨슈머가 `auto.commit.interval.ms` 마다 (기본 5초) 폴링 루프에 의해 자동 커밋하도록 할 수 있다.

=> `poll()` 메서드 실행마다 커밋 여부를 판단하고, 커밋 시 마지막 `poll()` 호출에서 리턴된 오프셋을 커밋한다.

만약 커밋되기 5초 이전에 컨슈머가 크래시 난다면 "이전 커밋 ~ 크래시 사이"의 메세지들은 이후 중복 처리되게 된다.
또한, 커밋하기 전 메세지 들은 실제로 처리되었는지 여부를 판단하기 어려우므로 모든 이벤트들을 처리하는 것이 중요하다.

> 오프셋을 더 자주 커밋하여 중복을 줄일 수는 있지만, 중복을 완전히 없애는 것은 불가능

## Manual Commit

메세지 유실의 가능성 제거 및 리밸런스 발생시 중복되는 메세지의 수를 줄이기 위해, 또는 원하는 시간에 현재 오프셋을 커밋하기 위해 수동으로 커밋을 실행할 수 있다.

### `commitSync()`


`poll()`이 리턴한 마지막 오프셋을 커밋한 뒤 커밋이 성공적으로 완료되면 리턴, 어떤 이유로 실패하면 예외를 발생

- 모든 레코드를 처리하기 전 API를 호출하면, 크래시 되었을 때 커밋은 되었지만 아직 처리되지 않은 메세지가 누락될 위험
- 레코드를 처리하는 중에 크래시가 날 경우 마지막 메세지 배치의 맨 앞 레코드 ~ 리밸런스 시작 시점까지의 레코드들은 중복 처리

`commitSync()`는 해결할 수 없는 에러가 발생하지 않는 한 커밋을 재시도한다.

> `commitSync()` 는 브로커가 커밋 요청에 응답할 때까지 애플리케이션이 블록되어 어플리케이션의 처리량을 제한시킨다.

### `commitAsync()`


`commitAsync()` 는 브로커가 커밋에 응답할 때까지 기다리지 않고 요청만 보낸 후 처리를 계속한다.

`commitSync()` 와 달리 커밋의 순서보장이 되지 않기 때문에 실패시 재시도를 하지 않는다.

또한, `commitAsync()` 는 브로커에게 응답을 받았을 때 호출되는 콜백을 지정할 수 있는데, 이 콜백을 사용하고자 할 때는 커밋 순서 관련 문제를 유의해야한다.

> sequence number를 사용하여 콜백에서 숫자를 비교해 콜백에서 주어진 번호가 더 크다면 새로운 커밋이 없다는 의미로 재시도를 할 수 있다.

🤪 *대체로, 재시도 없는 커밋이 가끔 실패하더라도 이후 커밋이 성공한다면 큰 문제가 되지 않는다.*

**=> 일반적인 패턴으로는 정상 상황에서는 `commitAsync()` 를 사용하고, 종료 직전에 `commitSync()`를 사용하여 마지막 메세지가 확실히 커밋되도록 한다.**

> `commit*()` 을 호출할 때 커밋하고자 하는 파티션과 오프셋 맵을 전달할 수 있어 마지막 오프셋 대신, 특정 오프셋을 전달 할 수 있다.


# Rebalance Listener

컨슈머가 종료하기 전이나 리밸런싱이 시작 되기 전에 정리작업을 하기 위해 `subscribe()` 호출 시 `ConsumerRebalanceListener`를 전달해주면 3가지 메서드를 구현할 수 있다.

1. `onPartitionsAssigned`
1. 리밸런싱이 발생할 때마다 호출, 새로 할당된 파티션이 없으면 빈 배열 리턴
2. `onPartitionsRevoked`
1. 일반적인 리밸런싱 상황에서 호출되지만, 파티션이 특정 컨슈머에서 해제될 때만 호출
3. `onPartitionsLost`
1. 예외적인 리밸런스 상황에서 호출


# Offset Seeking

일반적으로 각 파티션의 마지막으로 커밋된 오프셋부터 읽기를 시작하지만, `seekToBeginning` 과 `seekToEnd` , 혹은 특정 오프셋부터 읽기를 진행할 수도 있다.

- 시간에 민감한 애플리케이션에서 처리가 늦어져 몇 초 메세지를 건너뛰는 경우
- 파일에 데이터를 쓰는 컨슈머가 파일이 유실되어 데이터를 복구하기 위해 이전 시점으로 돌아가야 하는 경우

Q. 그럼 해당 컨슈머 그룹의 파티션 오프셋이 대체되는건가?
A. 커밋한다는 얘기는 없음. 말그대로 seeking

# Standalone Consumer

하나의 컨슈머가 토픽의 모든 파티션으로부터 모든 데이터를 읽어와야 하거나, 토픽의 특정 파티션으로부터 데이터를 읽어와야 할 때 등 **컨슈머 그룹이나 리밸런싱 기능을 제외한 독립 컨슈머를 사용할 수도 있다.**

컨슈머가 어떤 파티션을 읽어야 하는지 정확히 알고 있으면 토픽을 구독할 필요 없이 파티션을 할당받으면 된다.
(당연히 동시에 토픽을 구독하거나 컨슈머 그룹의 멤버십을 가질 수는 없다.)