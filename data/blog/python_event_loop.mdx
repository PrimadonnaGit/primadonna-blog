---
title: ChatGPT와 함께 이해하는 파이썬 비동기/이벤트 루프
date: "2023-11-21"
lastmod: "2023-11-21"
tags: ["python", "event loop", "fastAPI", "asyncIO"]
draft: false
summary: ChatGPT와 대화하며 이벤트 루프를 이해해보자
---

# 개요
FastAPI를 사용하면서 잘못 이해하고 있거나 헷갈리는 부분이 있어서, 이번 기회에 ChatGPT를 이용해 비동기와 이벤트 루프에 대해 정리해보려고 합니다.


## 코루틴 함수 내에서 일반 함수를 작성했을 때 이벤트 루프를 블로킹하나요?

이 문제에 대한 답변은 상황에 따라 다릅니다. 일반적으로, 일반 함수가 이벤트 루프를 '블로킹'한다는 것은 기술적으로 정확하지 않습니다.
대신, 일반 함수가 이벤트 루프의 다른 비동기 작업으로의 전환을 방해하거나 지연시킬 수 있다고 말하는 것이 더 정확합니다.
이를 설명하기 위해 두 가지 상황을 고려해 볼 수 있습니다

### 동기 함수가 CPU 바운드 작업을 수행하는 경우

이 경우, 동기 함수는 CPU를 차지하게 되며, 이벤트 루프가 다른 작업으로 전환하는 것을 실질적으로 방해합니다. 예를 들어, time.sleep()과 같은 함수는 프로그램의 실행을 일시 중단시키므로, 이벤트 루프가 다른 작업을 진행할 수 없게 됩니다. 이 상황에서는 동기 함수가 이벤트 루프를 '블로킹'한다고 표현할 수 있습니다.

### 동기 함수가 I/O 바운드 작업을 수행하는 경우

I/O 바운드 작업을 수행하는 동기 함수는 이벤트 루프가 다른 비동기 작업으로 전환하는 것을 지연시킬 수 있습니다. 그러나 I/O 작업 자체는 이벤트 루프를 차단하지 않습니다. 이 상황에서는 동기 함수가 이벤트 루프를 '지연시키는' 것이라고 표현하는 것이 더 적절합니다.

요약하자면, 동기 함수가 이벤트 루프를 '블로킹'한다고 일반화하기보다는 그 함수가 어떤 작업을 수행하는지에 따라 구분하는 것이 중요합니다.
CPU 바운드 작업을 수행하는 동기 함수는 이벤트 루프를 실질적으로 '블로킹'할 수 있으며, I/O 바운드 작업을 수행하는 동기 함수는 이벤트 루프의 다른 작업으로의 전환을 지연시킬 수 있습니다.

## 그런데 여러개의 코루틴함수들을 await하는 함수에서 어차피 이벤트 루프가 블로킹되는거나 마찬가지 아닌가요? 예를들어 아래와 같은 상황이에요.
```python
async def func1():
 await asyncFunction1()
 await asyncFunction2()
```

비동기 함수 내에서 여러 `await`를 사용하는 것이 이벤트 루프를 블로킹한다는 것은 잘못된 이해입니다.
오히려 비동기 프로그래밍의 핵심은 이벤트 루프를 효율적으로 사용하여 블로킹을 최소화하는 것입니다.

`await` 키워드는 비동기 함수가 결과를 반환할 때까지 현재의 코루틴 실행을 일시 중단합니다.
그러나 이것은 이벤트 루프가 다른 비동기 작업을 처리하지 못하게 한다는 의미는 아닙니다.
오히려 `await`를 사용하는 동안 이벤트 루프는 다른 비동기 작업으로 컨텍스트를 전환할 수 있어서 리소스를 효율적으로 사용할 수 있게 됩니다.

예를 들어, `func1`에서 `asyncFunction1()`이 `await` 되는 동안, `asyncFunction1()` 내부에서 발생하는 I/O 작업(예: HTTP 요청)이 진행되는 동안 이벤트 루프는 다른 코루틴을 실행할 수 있습니다.
`asyncFunction1()`의 작업이 완료되고 결과가 준비되면, 이벤트 루프는 다시 `func1`으로 돌아와서 다음 줄인 `await asyncFunction2()`를 실행합니다.

만약 `func1`이 여러 비동기 작업을 동시에 시작하고 싶다면, `asyncio.gather`를 사용하여 여러 코루틴을 동시에 스케줄링할 수 있습니다.
이렇게 하면 여러 작업이 병렬로 수행되고, 모든 작업이 완료되기를 기다립니다. 이 경우에는 `await`가 여러 작업이 동시에 실행될 수 있게 해주므로, 더욱 효율적인 비동기 처리가 가능합니다.

```python
async def func1():
    result1, result2 = await asyncio.gather(
        asyncFunction1(),
        asyncFunction2()
    )
```

이 코드에서 `asyncFunction1()`과 `asyncFunction2()`는 동시에 실행되고, 두 함수 모두 완료될 때까지 기다린 후에 그 결과를 반환합니다.
이 방식은 각 함수의 실행이 다른 함수의 실행을 기다리지 않기 때문에 이벤트 루프가 블로킹되는 것을 방지합니다.

## 그럼 코루틴함수가 I/O 작업을 하고 있을 때 다른 비동기 작업을 처리할 수 있다는 얘기는, 두 async 함수가 동시에 실행된다는 얘기는 아닌거네요?

맞습니다. Python의 비동기 모델은 멀티쓰레딩이나 멀티프로세싱과는 다릅니다. 비동기 모델에서는 동시에 두 가지 일을 하는 것처럼 보이지만, 실제로는 한 시점에 하나의 작업만 실행됩니다.
`await` 키워드를 사용하면, 해당 작업이 완료될 때까지 현재의 코루틴을 일시 정지하고, 이벤트 루프는 다른 코루틴을 실행할 수 있게 됩니다.

즉, `await`를 사용하는 비동기 함수는 I/O 작업(예: 네트워크 요청, 디스크 읽기/쓰기 등)이 블로킹 되는 것을 기다리는 대신, 이벤트 루프가 다른 작업으로 전환할 수 있도록 합니다.
이로 인해 단일 쓰레드 내에서도 마치 병렬처럼 여러 작업을 효율적으로 처리할 수 있습니다.

`asyncio.gather`와 같은 함수를 사용하면 여러 비동기 작업을 "동시에" 시작할 수 있고, 이벤트 루프는 각 작업이 I/O로 블로킹 되는 동안 다른 작업으로 전환하여 실행합니다.
하지만 실제로 CPU는 한 번에 하나의 코루틴만 실행하며, 이러한 작업의 전환은 매우 빠르게 일어나서 동시에 수행되는 것처럼 보이게 만듭니다.

이것은 "비동기 동시성"이라고 할 수 있으며, 실제 "병렬성"과는 다른 개념입니다.
병렬성은 멀티코어 CPU에서 여러 쓰레드나 프로세스가 실제로 동시에 실행되는 것을 의미합니다.
비동기 동시성은 단일 쓰레드에서 효율적으로 여러 I/O 중심의 작업을 처리할 수 있게 해줍니다.

## 그럼 fastapi를 통해 여러개의 요청이 들어오는 상황에서 두가지 async 함수(A, B)가 번갈아 사용된다고 가정했을 때 위에서 말한 이벤트 루프가 다른 작업으로 전환될 수 있다는건 A,B 의 작업이 번갈아 작동된다는건가요?

네, 맞습니다. FastAPI와 같은 비동기 웹 프레임워크에서 여러 요청이 동시에 들어올 때 각 요청은 별도의 비동기 함수(코루틴)로 처리됩니다.
예를 들어, A와 B 두 개의 비동기 함수가 있다고 할 때, 각 요청은 이 두 함수 중 하나에 매핑될 것입니다.

만약 요청 1이 함수 A를 실행하고, 그 함수가 `await` 키워드를 만나 I/O 작업을 기다리고 있는 동안, 이벤트 루프는 요청 2가 함수 B를 호출하도록 전환할 수 있습니다.
함수 B 또한 `await`을 만나면, 이벤트 루프는 다시 요청 1의 함수 A로 돌아가거나, 새로운 요청 3이 들어오면 해당 요청을 처리할 새로운 코루틴을 시작할 수 있습니다.

이런 식으로 이벤트 루프는 각 비동기 작업의 I/O 대기 시간을 이용하여, 다른 요청을 처리하는 다른 코루틴으로 빠르게 전환함으로써, 단일 쓰레드에서도 많은 요청을 효율적으로 처리할 수 있습니다.
이러한 이유로 비동기 프로그래밍은 I/O 바운드 작업에서 매우 높은 성능을 발휘할 수 있습니다.

그러나 중요한 점은, 이벤트 루프가 한 번에 하나의 코루틴만 실행할 수 있다는 것입니다.
따라서, `await` 없이 CPU를 많이 사용하는 작업을 실행하면, 해당 작업이 완료될 때까지 다른 코루틴으로 전환할 수 없어서 성능 문제가 발생할 수 있습니다.
이런 작업들은 비동기 실행보다는 멀티쓰레딩이나 멀티프로세싱을 사용하여 처리하는 것이 더 적합할 수 있습니다.

## 그럼 이벤트 루프는 서버당 하나의 이벤트 루프만 가지고 있나요?

일반적으로 Python의 비동기 프로그래밍 모델에서는 프로세스 당 하나의 이벤트 루프를 사용합니다. 이것은 `asyncio` 모듈이 작동하는 기본적인 방식입니다.
이벤트 루프는 실행 중인 모든 비동기 작업을 관리하고, 어떤 코루틴을 실행할지, 언제 네트워크 I/O를 수행할지, 타이머 이벤트가 있을 때 어떻게 할지 등을 결정합니다.

그러나, 이벤트 루프를 여러 개 실행하는 것도 가능합니다.
예를 들어, 여러 개의 프로세스를 사용하여 각 프로세스마다 자체 이벤트 루프를 실행할 수 있습니다.
이는 병렬성과 비동기 동시성을 결합하여 성능을 향상시키는 한 방법입니다.

FastAPI와 같은 비동기 웹 프레임워크는 `Uvicorn`이나 `Hypercorn`과 같은 ASGI 서버에서 실행될 때, 일반적으로 멀티프로세스 설정을 통해 여러 프로세스에서 애플리케이션을 복제하여 실행할 수 있습니다.
이 경우 각 프로세스는 독립적인 이벤트 루프를 가지게 됩니다.

또 다른 방법은 `asyncio`의 이벤트 루프를 명시적으로 관리하는 것입니다.
예를 들어, 새로운 쓰레드에서 새 이벤트 루프를 시작하고, 그 쓰레드의 콘텍스트에서 비동기 작업을 실행하는 것입니다.
그러나 이 방법은 복잡하고 동기화 이슈를 야기할 수 있어 일반적인 사용 사례에서는 권장되지 않습니다.

요약하자면, 기본적으로 하나의 프로세스는 하나의 이벤트 루프를 사용하지만, 시스템 아키텍처에 따라 여러 이벤트 루프를 운영할 수는 있습니다.
그러나 이러한 설계는 추가적인 복잡성을 도입하며, 각각의 사용 사례에 따라 그 가치와 비용을 잘 평가해야 합니다.

## fastapi의 공식 문서를 살펴보면, async 경로 함수 내에 사용된 일반 함수는 외부 쓰레드 풀에서 실행된다고 나와있는데, 이것은 이벤트 루프를 블로킹하지 않는다는 얘기인가요?

FastAPI 문서에 설명된 내용을 기반으로 해석하면 다음과 같습니다:

일반적인 `def`를 사용하여 경로 작업 함수를 선언하면 해당 함수는 서버를 차단하지 않고 외부 쓰레드 풀에서 실행되어 기다려지게 됩니다(`async def` 대신에 사용될 때).
이는 함수가 직접 호출되는 대신 비동기적으로 처리됨을 의미합니다.

다른 비동기 프레임워크에서 미세한 성능 향상을 위해 `def`를 사용하는 것에 익숙하다면, FastAPI에서는 그 효과가 정반대라는 것에 주의해야 합니다.
FastAPI에서는 동기 코드가 외부 쓰레드 풀에서 실행되므로, 비동기 `async def`를 사용하지 않는 경우 오히려 성능이 저하될 수 있습니다.

따라서 경로 작업 함수가 차단 I/O를 수행하지 않는 한, `async def`를 사용하는 것이 더 낫습니다.

종속성(dependencies)에 대해서도 같은 규칙이 적용됩니다. `async def`가 아닌 일반 `def` 함수로 선언된 종속성은 외부 쓰레드 풀에서 실행됩니다.

여러 종속성과 하위 종속성이 서로를 필요로 하는 경우(함수 정의의 매개변수로 요구됨), 일부는 `async def`로, 다른 일부는 일반 `def`로 생성될 수 있습니다.
이런 경우에도 잘 작동하며, 일반 `def`로 생성된 것들은 쓰레드 풀에서 호출됩니다.

FastAPI가 직접 호출하는 경로 작업 함수와 종속성과는 달리, 직접 호출하는 다른 유틸리티 함수는 `def` 또는 `async def`를 사용하여 생성할 수 있으며, FastAPI는 호출 방식에 영향을 주지 않습니다.

유틸리티 함수가 일반 `def` 함수인 경우, 코드에서 직접 호출될 것이며, 쓰레드풀에서 실행되지 않습니다. 만약 함수가 `async def`로 생성된 경우, 코드에서 해당 함수를 호출할 때 `await`해야 합니다.

이 내용을 토대로, FastAPI는 경로 작업 함수와 종속성을 처리할 때 동기 함수를 자동으로 쓰레드 풀에서 실행하여 비동기 처리가 가능하게 하는 것으로 보입니다.
이는 개발자가 명시적으로 `run_in_threadpool`을 호출하지 않아도 내부적으로 비동기 처리를 수행함으로써 이벤트 루프의 차단을 방지하고, 동시에 여러 요청을 더 효율적으로 처리할 수 있게 해줍니다.

## 외부 쓰레드 풀이라는 건 뭔가요?

"외부 쓰레드 풀"은 FastAPI가 내부적으로 사용하는 쓰레드 풀입니다. 이 쓰레드 풀은 `asyncio`의 기능을 활용하여 동기 함수를 비동기 환경에서 실행할 수 있게 해주며, 이를 통해 메인 이벤트 루프가 차단되는 것을 방지합니다.
즉, 메인 이벤트 루프는 비동기 작업을 계속해서 처리할 수 있고, 동시에 동기 함수는 별도의 쓰레드에서 실행됩니다.

`asyncio`의 이벤트 루프는 `concurrent.futures.ThreadPoolExecutor를` 기본 실행자로 사용하는 `run_in_executor` 메서드를 제공합니다.
이 메서드를 사용하면, 개발자가 별도의 작업을 하지 않아도 내부적으로 쓰레드 풀에서 동기 함수를 실행할 수 있습니다. 쓰레드 풀은 제한된 수의 쓰레드를 유지하며, 각 쓰레드는 동기 함수를 실행하고 결과를 반환합니다.
이 쓰레드 풀은 "외부"라고 불리는 이유는 메인 프로그램의 비동기 이벤트 루프 밖에 존재하기 때문입니다.

FastAPI에서는 동기 함수를 비동기 경로 함수 내에서 호출할 때 자동으로 이 쓰레드 풀을 사용하여 동기 함수를 비동기적으로 실행할 수 있도록 해줍니다.
이로 인해 동기 함수가 I/O 작업이나 다른 차단 연산을 수행할 때 메인 이벤트 루프가 그 작업을 기다리지 않고 다른 비동기 작업을 계속 처리할 수 있습니다.
이 기능은 FastAPI의 사용성과 성능을 크게 향상시키는 중요한 요소 중 하나입니다.

## 파이썬은 기본적으로는 gil 때문에 하나의 쓰레드만 사용가능하다고 알고 있는데, 외부 쓰레드 풀에서 여러개의 쓰레드를 사용할 수 있다는건 어떤 원리인가요?

파이썬에서 GIL(Global Interpreter Lock)이란, CPython 인터프리터가 멀티쓰레딩 환경에서 안전하게 실행될 수 있도록 하는 메커니즘입니다.
GIL은 한 번에 하나의 쓰레드만이 파이썬 코드를 실행할 수 있도록 제한하여, 공유 자원에 대한 동시 접근을 방지합니다.
이로 인해 CPU 바운드 작업을 수행하는 멀티쓰레드 프로그램은 병렬 실행의 이점을 완전히 활용하지 못하게 됩니다.

그러나 GIL은 I/O 바운드 작업, 즉 파일 시스템 작업이나 네트워크 요청과 같이 CPU보다는 외부 자원의 대기 시간이 더 큰 작업에 대해서는 크게 문제가 되지 않습니다.
I/O 바운드 작업에서는 대부분의 시간이 I/O 처리를 기다리는 데 소요되므로, 쓰레드가 블록되어 있는 동안 다른 쓰레드가 실행될 수 있습니다.
따라서, 파이썬에서 I/O 바운드 작업을 멀티쓰레딩으로 처리하는 것은 여전히 효과적입니다.

FastAPI와 같은 비동기 프레임워크에서 사용되는 "외부 쓰레드 풀"은 I/O 바운드 작업을 병렬로 처리하기 위해 사용됩니다.
`asyncio`는 내부적으로 비동기 I/O 작업을 최적화하고, 동기 작업이 필요할 때는 `ThreadPoolExecutor`를 사용하여 별도의 쓰레드에서 실행할 수 있도록 합니다.
이 방식은 GIL의 영향을 받지만, I/O 바운드 작업에 대한 병렬 처리에는 여전히 효율적입니다.

또한, CPU 바운드 작업의 경우에는 `concurrent.futures.ProcessPoolExecutor`를 사용하여 멀티 프로세싱을 구현할 수 있습니다.
이는 각각의 프로세스가 자체 파이썬 인터프리터와 GIL을 가지기 때문에, 실제로 멀티 코어 CPU에서 병렬 처리를 할 수 있게 해줍니다.

요약하면, GIL은 멀티쓰레딩의 효율성을 제한하지만, I/O 바운드 작업에서는 멀티쓰레딩이 유용할 수 있고, CPU 바운드 작업에 대해서는 멀티 프로세싱을 사용하여 GIL의 제약을 우회할 수 있습니다.
FastAPI의 외부 쓰레드 풀은 주로 I/O 바운드 작업을 비동기적으로 처리하기 위해 사용됩니다.

## 그럼 하나의 쓰레드만 사용할 수 있다는 얘기는 "동시"에 하나만 사용할 수 있다 인거네요?

예, 맞습니다. GIL(Global Interpreter Lock) 때문에 CPython 인터프리터를 사용하는 파이썬에서는 한 번에 하나의 쓰레드만이 Python bytecode를 실행할 수 있습니다.
이는 CPU 바운드 작업에 대해 파이썬의 멀티쓰레딩이 다른 언어에 비해 효율적이지 않다는 것을 의미합니다.
왜냐하면, 실제로 여러 쓰레드가 동시에 실행되는 것이 아니라, GIL이 쓰레드 간에 빠르게 전환되면서 실행되기 때문입니다.

그러나 I/O 바운드 작업에서는 쓰레드가 데이터를 기다리는 동안 다른 쓰레드가 실행될 수 있기 때문에, 멀티쓰레딩이 여전히 유용합니다.
이러한 이유로 I/O 바운드 작업을 수행하는 웹 서버와 같은 응용 프로그램에서는 멀티쓰레딩이나 비동기 프로그래밍이 효과적으로 사용될 수 있습니다.

FastAPI와 같은 비동기 웹 프레임워크는 이벤트 루프를 사용하여 비동기 작업을 관리하고, 필요한 경우 외부 쓰레드 풀(멀티쓰레딩)을 사용하여 동기 코드를 실행함으로써, 단일 쓰레드의 제약을 극복하고 높은 동시성을 달성합니다.

